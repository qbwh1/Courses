WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.708
在这个循环嵌套结构里

00:00:02.708 --> 00:00:04.530
里面的这个小循环

00:00:04.530 --> 00:00:08.039
通常被称为内循环

00:00:08.039 --> 00:00:10.634
每当外循环进入这里面

00:00:10.634 --> 00:00:14.625
它就会将循环计数器重设为 0

00:00:14.625 --> 00:00:16.320
迫使其输出 “Hi” 这条信息三次

00:00:16.320 --> 00:00:20.730
也就是说 外循环将会

00:00:20.730 --> 00:00:26.365
重复执行输出 3 遍信息 每次连续输出三次

00:00:26.364 --> 00:00:30.144
这就是这条信息总共会输出九次的原因

00:00:30.144 --> 00:00:33.149
我们现在来跟踪这个程序的每一步

00:00:33.149 --> 00:00:36.839
看看变量 i 和 j 是怎么变化的

00:00:36.840 --> 00:00:38.810
开始外循环

00:00:38.810 --> 00:00:40.202
i 初始化为 0

00:00:40.201 --> 00:00:42.640
将其值设为 0

00:00:42.640 --> 00:00:46.420
然后判断 i 是否小于 3

00:00:46.420 --> 00:00:47.950
是的

00:00:47.950 --> 00:00:51.635
于是进到这里面 来到内循环

00:00:51.634 --> 00:00:55.475
因此 j 被初始化为 0 记下这个值

00:00:55.475 --> 00:00:58.060
然后判断 j 是否小于 3

00:00:58.060 --> 00:01:01.437
是的 于是进入内循环

00:01:01.436 --> 00:01:03.003
输出语句 “Hi!”

00:01:03.003 --> 00:01:07.105
到达内循环尾部 我们回到这上面来

00:01:07.105 --> 00:01:10.359
判断 给 j 加 1

00:01:10.359 --> 00:01:13.194
使其值从 0 变为 1

00:01:13.194 --> 00:01:15.009
增量好后

00:01:15.010 --> 00:01:17.155
判断 j 是否仍小于 3

00:01:17.155 --> 00:01:18.700
是的

00:01:18.700 --> 00:01:22.704
所以再次进入循环 再次输出 “Hi!”

00:01:22.704 --> 00:01:25.004
到达循环尾部

00:01:25.004 --> 00:01:28.810
于是我们回到这上面来 再给 j 加 1

00:01:28.810 --> 00:01:31.870
判断 j 是否仍小于 3 是的

00:01:31.870 --> 00:01:36.290
所以再次进入循环 又一次输出 “Hi!”

00:01:36.290 --> 00:01:38.355
现在我们到了循环尾部

00:01:38.355 --> 00:01:40.150
回来 给 j 加 1

00:01:40.150 --> 00:01:44.800
使其为 3 再次判断 j 是否小于 3

00:01:44.799 --> 00:01:46.500
条件不再为真

00:01:46.501 --> 00:01:51.995
所以直接跳到内循环末尾 从这里继续往下

00:01:51.995 --> 00:01:54.390
不过内循环之后就没有东西了

00:01:54.390 --> 00:01:56.844
所以我们到了外循环的右括号这

00:01:56.844 --> 00:02:00.079
也就意味着我们得回去 这次得给 i 增量

00:02:00.079 --> 00:02:02.620
i 从 0 变为 1

00:02:02.620 --> 00:02:06.865
判断 i 是否仍小于 3 是的

00:02:06.864 --> 00:02:09.840
意味着我们要进入循环

00:02:09.840 --> 00:02:12.170
进入外循环

00:02:12.169 --> 00:02:14.174
我们又看到了这个内循环

00:02:14.175 --> 00:02:19.330
所以我们得从头开始 包括执行初始化操作 于是 j 重置为 0

00:02:19.330 --> 00:02:21.205
然后判断 j 是否小于 3

00:02:21.205 --> 00:02:24.225
是的 所以再次输出

00:02:24.224 --> 00:02:26.079
于是 Hi! 得以再次被输出

00:02:26.080 --> 00:02:28.893
到达内循环右括号

00:02:28.893 --> 00:02:31.375
回来 给 j 增量

00:02:31.375 --> 00:02:34.824
从 0 变为 1 判断是否小于 3

00:02:34.824 --> 00:02:36.569
是的 于是再次输出 “Hi!”

00:02:36.569 --> 00:02:40.629
再次结束内循环

00:02:40.629 --> 00:02:42.277
回来 将其增量为 2

00:02:42.277 --> 00:02:44.469
判断是否小于 3

00:02:44.469 --> 00:02:46.210
是的

00:02:46.210 --> 00:02:52.030
又一次输出 “Hi!” 重复这一步 直到 j++ 把值变为 3

00:02:52.030 --> 00:02:53.960
这个时候我们判断 j 是否小于 3

00:02:53.960 --> 00:02:55.219
条件就不再为真了

00:02:55.219 --> 00:02:59.590
我们不再输出任何东西 跳到内循环的右括号来

00:02:59.590 --> 00:03:02.487
继续 后面没有别的操作了

00:03:02.487 --> 00:03:06.759
于是到达外循环的右括号 而 i 仍小于 3

00:03:06.759 --> 00:03:07.974
所以回来

00:03:07.974 --> 00:03:12.939
将 i 增量为 2 判断 i 是否小于 3

00:03:12.939 --> 00:03:14.469
是的

00:03:14.469 --> 00:03:16.490
所以再次进入内循环

00:03:16.491 --> 00:03:19.615
再次将 j 初始化为 0

00:03:19.615 --> 00:03:21.828
由于 0 小于 3

00:03:21.828 --> 00:03:23.770
所以我们又要开始输出了

00:03:23.770 --> 00:03:26.950
这会使得内循环不断重复

00:03:26.949 --> 00:03:30.829
输出 “Hi!”

00:03:30.830 --> 00:03:32.230
还是连续三次

00:03:32.229 --> 00:03:35.399
等到内循环计数器变为 3 后

00:03:35.400 --> 00:03:39.490
这个条件变为假 所以我们直接跳到尾部

00:03:39.490 --> 00:03:41.980
到达外循环的右括号 再回来

00:03:41.979 --> 00:03:44.814
这次将 i 增量为 3

00:03:44.814 --> 00:03:46.772
而 3 不再小于 3

00:03:46.772 --> 00:03:49.518
因此不会再进入内循环了

00:03:49.518 --> 00:03:54.490
而是直接跳到外循环的右括号 程序结束

00:03:54.490 --> 00:03:59.414
不知道你是否有注意 i 会从 0 变为 3 而 i 每增加一个值

00:03:59.413 --> 00:04:01.095
j 就会从 0 变为 3

00:04:01.096 --> 00:04:03.030
这就是循环嵌套的原理

00:04:03.030 --> 00:04:08.330
很多情况下 你可以在内循环中交替使用 i 和 j

00:04:08.330 --> 00:04:10.719
打个比方 我们来看看如何用循环嵌套

00:04:10.719 --> 00:04:13.479
来访问一个二维数组

00:04:13.479 --> 00:04:16.819
回到这里的二维网格

00:04:16.819 --> 00:04:22.610
我们想知道如何访问这个二维数组里的每个数字

00:04:22.610 --> 00:04:26.745
我们已经知道 如果想访问一行里的每一项

00:04:26.745 --> 00:04:29.449
我们只需写一个循环就行了

00:04:29.449 --> 00:04:30.839
而这个循环

00:04:30.839 --> 00:04:35.914
会访问索引为 0 的行的每一项

00:04:35.915 --> 00:04:40.215
也就意味着它会统计这些数字 因为我们是把它们和 total 相加

00:04:40.214 --> 00:04:42.104
所以等循环结束后

00:04:42.105 --> 00:04:46.754
我们 total 的值就会等于该行中所有项的总和

00:04:46.754 --> 00:04:49.064
如果我们想把其它行也加进来

00:04:49.064 --> 00:04:52.314
那我们可以为每一行写一个循环

00:04:52.314 --> 00:04:55.154
唯一不同的是这里的索引

00:04:55.154 --> 00:04:58.854
要换成目的行的索引

00:04:58.855 --> 00:05:00.305
等我们运行这些代码

00:05:00.305 --> 00:05:03.584
程序就会访问每一行

00:05:03.584 --> 00:05:09.739
以及行里的每一项 然后不断地累加 直到我们得到了想要的 total 值

00:05:09.740 --> 00:05:14.824
不过如果你有注意到的话 你会发现这些循环除了索引 几乎一模一样

00:05:14.824 --> 00:05:17.774
而索引是从 0 变为 3 的

00:05:17.774 --> 00:05:20.370
看起来我们好像可以把这些套到循环里

00:05:20.370 --> 00:05:22.500
如果我们把其中一个循环

00:05:22.500 --> 00:05:26.327
用另一个循环套起来 然后用这一整个循环的计数器作为索引

00:05:26.327 --> 00:05:29.169
那么这个大循环会和这些代码具备一样的功能

00:05:29.170 --> 00:05:32.694
所以 如果我们把这些代码换成这样

00:05:32.694 --> 00:05:35.714
也就是在这使用循环嵌套结构

00:05:35.714 --> 00:05:41.199
一个循环用循环计数器 i 另一个用计数器 j

00:05:41.199 --> 00:05:45.101
如果我们访问 grades [i] [j]

00:05:45.101 --> 00:05:49.349
程序最终就会把数组里的所有项都累加起来

00:05:49.350 --> 00:05:50.610
执行这段代码

00:05:50.610 --> 00:05:53.160
内循环就会访问一行里的每一项

00:05:53.160 --> 00:05:55.620
而外循环则确保我们会移到下一行

00:05:55.620 --> 00:05:58.199
接着内循环再访问这一行里的每一项

00:05:58.199 --> 00:06:00.944
这么一来

00:06:00.944 --> 00:06:03.029
我们就能确保 等代码执行完毕后

00:06:03.029 --> 00:06:05.939
我们已经将网格里的每一项都访问完毕了

00:06:05.939 --> 00:06:10.110
由于每次我们都把 grades 的值与变量 total 相加

00:06:10.110 --> 00:06:12.525
所以等这个循环嵌套结束后

00:06:12.524 --> 00:06:17.964
total 就会是这个二维数组里所有值的总和

00:06:17.964 --> 00:06:20.939
完美 除了累加 你能做的还有很多

00:06:20.939 --> 00:06:23.519
比如 你可以找出二维数组里的最小值和最大值

00:06:23.519 --> 00:06:27.629
方法也是用这个循环嵌套结构

